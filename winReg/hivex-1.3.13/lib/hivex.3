.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "hivex 3"
.TH hivex 3 "2015-02-21" "hivex-1.3.13" "Windows Registry"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
hivex \- Windows Registry "hive" extraction library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <hivex.h>
\&
\& hive_h *hivex_open (const char *filename, int flags);
\& int hivex_close (hive_h *h);
\& hive_node_h hivex_root (hive_h *h);
\& int64_t hivex_last_modified (hive_h *h);
\& char *hivex_node_name (hive_h *h, hive_node_h node);
\& size_t hivex_node_name_len (hive_h *h, hive_node_h node);
\& int64_t hivex_node_timestamp (hive_h *h, hive_node_h node);
\& hive_node_h *hivex_node_children (hive_h *h, hive_node_h node);
\& hive_node_h hivex_node_get_child (hive_h *h, hive_node_h node, const char *name);
\& hive_node_h hivex_node_parent (hive_h *h, hive_node_h node);
\& hive_value_h *hivex_node_values (hive_h *h, hive_node_h node);
\& hive_value_h hivex_node_get_value (hive_h *h, hive_node_h node, const char *key);
\& size_t hivex_value_key_len (hive_h *h, hive_value_h val);
\& char *hivex_value_key (hive_h *h, hive_value_h val);
\& int hivex_value_type (hive_h *h, hive_value_h val, hive_type *t, size_t *len);
\& size_t hivex_node_struct_length (hive_h *h, hive_node_h node);
\& size_t hivex_value_struct_length (hive_h *h, hive_value_h val);
\& hive_value_h hivex_value_data_cell_offset (hive_h *h, hive_value_h val, size_t *len);
\& char *hivex_value_value (hive_h *h, hive_value_h val, hive_type *t, size_t *len);
\& char *hivex_value_string (hive_h *h, hive_value_h val);
\& char **hivex_value_multiple_strings (hive_h *h, hive_value_h val);
\& int32_t hivex_value_dword (hive_h *h, hive_value_h val);
\& int64_t hivex_value_qword (hive_h *h, hive_value_h val);
\& int hivex_commit (hive_h *h, const char *filename, int flags);
\& hive_node_h hivex_node_add_child (hive_h *h, hive_node_h parent, const char *name);
\& int hivex_node_delete_child (hive_h *h, hive_node_h node);
\& int hivex_node_set_values (hive_h *h, hive_node_h node, size_t nr_values, const hive_set_value *values, int flags);
\& int hivex_node_set_value (hive_h *h, hive_node_h node, const hive_set_value *val, int flags);
.Ve
.PP
Link with \fI\-lhivex\fR.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Hivex is a library for extracting the contents of Windows Registry
\&\*(L"hive\*(R" files.  It is designed to be secure against buggy or malicious
registry files.
.PP
Unlike other tools in this area, it doesn't use the textual .REG
format, because parsing that is as much trouble as parsing the
original binary format.  Instead it makes the file available
through a C \s-1API,\s0 and then wraps this \s-1API\s0 in higher level scripting
and \s-1GUI\s0 tools.
.PP
There is a separate program to export the hive as \s-1XML
\&\s0(see \fIhivexml\fR\|(1)), or to navigate the file (see \fIhivexsh\fR\|(1)).
There is also a Perl script to export and merge the
file as a textual .REG (regedit) file, see \fIhivexregedit\fR\|(1).
.PP
If you just want to export or modify the Registry of a Windows
virtual machine, you should look at \fIvirt\-win\-reg\fR\|(1).
.PP
Hivex is also comes with language bindings for
OCaml, Perl, Python and Ruby.
.SH "TYPES"
.IX Header "TYPES"
.ie n .SS """hive_h *"""
.el .SS "\f(CWhive_h *\fP"
.IX Subsection "hive_h *"
This handle describes an open hive file.
.ie n .SS """hive_node_h"""
.el .SS "\f(CWhive_node_h\fP"
.IX Subsection "hive_node_h"
This is a node handle, an integer but opaque outside the library.
Valid node handles cannot be 0.  The library returns 0 in some
situations to indicate an error.
.ie n .SS """hive_type"""
.el .SS "\f(CWhive_type\fP"
.IX Subsection "hive_type"
The enum below describes the possible types for the value(s)
stored at each node.  Note that you should not trust the
type field in a Windows Registry, as it very often has no
relationship to reality.  Some applications use their own
types.  The encoding of strings is not specified.  Some
programs store everything (including strings) in binary blobs.
.PP
.Vb 10
\& enum hive_type {
\&   /* Just a key without a value */
\&   hive_t_REG_NONE = 0,
\&   /* A Windows string (encoding is unknown, but often UTF16\-LE) */
\&   hive_t_REG_SZ = 1,
\&   /* A Windows string that contains %env% (environment variable expansion) */
\&   hive_t_REG_EXPAND_SZ = 2,
\&   /* A blob of binary */
\&   hive_t_REG_BINARY = 3,
\&   /* DWORD (32 bit integer), little endian */
\&   hive_t_REG_DWORD = 4,
\&   /* DWORD (32 bit integer), big endian */
\&   hive_t_REG_DWORD_BIG_ENDIAN = 5,
\&   /* Symbolic link to another part of the registry tree */
\&   hive_t_REG_LINK = 6,
\&   /* Multiple Windows strings.  See http://blogs.msdn.com/oldnewthing/archive/2009/10/08/9904646.aspx */
\&   hive_t_REG_MULTI_SZ = 7,
\&   /* Resource list */
\&   hive_t_REG_RESOURCE_LIST = 8,
\&   /* Resource descriptor */
\&   hive_t_REG_FULL_RESOURCE_DESCRIPTOR = 9,
\&   /* Resouce requirements list */
\&   hive_t_REG_RESOURCE_REQUIREMENTS_LIST = 10,
\&   /* QWORD (64 bit integer), unspecified endianness but usually little endian */
\&   hive_t_REG_QWORD = 11,
\&};
.Ve
.ie n .SS """hive_value_h"""
.el .SS "\f(CWhive_value_h\fP"
.IX Subsection "hive_value_h"
This is a value handle, an integer but opaque outside the library.
Valid value handles cannot be 0.  The library returns 0 in some
situations to indicate an error.
.ie n .SS """hive_set_value"""
.el .SS "\f(CWhive_set_value\fP"
.IX Subsection "hive_set_value"
The typedef \f(CW\*(C`hive_set_value\*(C'\fR is used in conjunction with the
\&\f(CW\*(C`hivex_node_set_values\*(C'\fR call described below.
.PP
.Vb 7
\& struct hive_set_value {
\&   char *key;     /* key \- a UTF\-8 encoded ASCIIZ string */
\&   hive_type t;   /* type of value field */
\&   size_t len;    /* length of value field in bytes */
\&   char *value;   /* value field */
\& };
\& typedef struct hive_set_value hive_set_value;
.Ve
.PP
To set the default value for a node, you have to pass \f(CW\*(C`key = ""\*(C'\fR.
.PP
Note that the \f(CW\*(C`value\*(C'\fR field is just treated as a list of bytes, and
is stored directly in the hive.  The caller has to ensure correct
encoding and endianness, for example converting dwords to little
endian.
.PP
The correct type and encoding for values depends on the node and key
in the registry, the version of Windows, and sometimes even changes
between versions of Windows for the same key.  We don't document it
here.  Often it's not documented at all.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "hivex_open"
.IX Subsection "hivex_open"
.Vb 1
\& hive_h *hivex_open (const char *filename, int flags);
.Ve
.PP
Opens the hive named \f(CW\*(C`filename\*(C'\fR for reading.
.PP
Flags is an ORed list of the open flags (or \f(CW0\fR if you don't
want to pass any flags).  These flags are defined:
.IP "\s-1HIVEX_OPEN_VERBOSE\s0" 4
.IX Item "HIVEX_OPEN_VERBOSE"
Verbose messages.
.IP "\s-1HIVEX_OPEN_DEBUG\s0" 4
.IX Item "HIVEX_OPEN_DEBUG"
Very verbose messages, suitable for debugging problems in the library
itself.
.Sp
This is also selected if the \f(CW\*(C`HIVEX_DEBUG\*(C'\fR environment variable
is set to 1.
.IP "\s-1HIVEX_OPEN_WRITE\s0" 4
.IX Item "HIVEX_OPEN_WRITE"
Open the hive for writing.  If omitted, the hive is read-only.
.Sp
See \*(L"\s-1WRITING TO HIVE FILES\*(R"\s0 in \fIhivex\fR\|(3).
.PP
Returns a new hive handle.
On error this returns \s-1NULL\s0 and sets errno.
.SS "hivex_close"
.IX Subsection "hivex_close"
.Vb 1
\& int hivex_close (hive_h *h);
.Ve
.PP
Close a hive handle and free all associated resources.
.PP
Note that any uncommitted writes are \fInot\fR committed by this call,
but instead are lost.  See \*(L"\s-1WRITING TO HIVE FILES\*(R"\s0 in \fIhivex\fR\|(3).
.PP
Returns 0 on success.
On error this returns \-1 and sets errno.
.PP
This function frees the hive handle (even if it returns an error).
The hive handle must not be used again after calling this function.
.SS "hivex_root"
.IX Subsection "hivex_root"
.Vb 1
\& hive_node_h hivex_root (hive_h *h);
.Ve
.PP
Return root node of the hive.  All valid hives must contain a root node.
.PP
Returns a node handle.
On error this returns 0 and sets errno.
.SS "hivex_last_modified"
.IX Subsection "hivex_last_modified"
.Vb 1
\& int64_t hivex_last_modified (hive_h *h);
.Ve
.PP
Return the modification time from the header of the hive.
.PP
The returned value is a Windows filetime.
To convert this to a Unix \f(CW\*(C`time_t\*(C'\fR see:
<http://stackoverflow.com/questions/6161776/convert\-windows\-filetime\-to\-second\-in\-unix\-linux/6161842#6161842>
.SS "hivex_node_name"
.IX Subsection "hivex_node_name"
.Vb 1
\& char *hivex_node_name (hive_h *h, hive_node_h node);
.Ve
.PP
Return the name of the node.
.PP
Note that the name of the root node is a dummy, such as
\&\f(CW\*(C`$$$PROTO.HIV\*(C'\fR (other names are possible: it seems to depend on the
tool or program that created the hive in the first place).  You can
only know the \*(L"real\*(R" name of the root node by knowing which registry
file this hive originally comes from, which is knowledge that is
outside the scope of this library.
.PP
The name is recoded to \s-1UTF\-8\s0 and may contain embedded \s-1NUL\s0 characters.
.PP
Returns a string.
The string must be freed by the caller when it is no longer needed.
On error this returns \s-1NULL\s0 and sets errno.
.SS "hivex_node_name_len"
.IX Subsection "hivex_node_name_len"
.Vb 1
\& size_t hivex_node_name_len (hive_h *h, hive_node_h node);
.Ve
.PP
Return the length of the node name as produced by \f(CW\*(C`hivex_node_name\*(C'\fR.
.PP
Returns a size.
On error this returns 0 and sets errno.
.SS "hivex_node_timestamp"
.IX Subsection "hivex_node_timestamp"
.Vb 1
\& int64_t hivex_node_timestamp (hive_h *h, hive_node_h node);
.Ve
.PP
Return the modification time of the node.
.PP
The returned value is a Windows filetime.
To convert this to a Unix \f(CW\*(C`time_t\*(C'\fR see:
<http://stackoverflow.com/questions/6161776/convert\-windows\-filetime\-to\-second\-in\-unix\-linux/6161842#6161842>
.SS "hivex_node_children"
.IX Subsection "hivex_node_children"
.Vb 1
\& hive_node_h *hivex_node_children (hive_h *h, hive_node_h node);
.Ve
.PP
Return an array of nodes which are the subkeys
(children) of \f(CW\*(C`node\*(C'\fR.
.PP
Returns a 0\-terminated array of nodes.
The array must be freed by the caller when it is no longer needed.
On error this returns \s-1NULL\s0 and sets errno.
.SS "hivex_node_get_child"
.IX Subsection "hivex_node_get_child"
.Vb 1
\& hive_node_h hivex_node_get_child (hive_h *h, hive_node_h node, const char *name);
.Ve
.PP
Return the child of node with the name \f(CW\*(C`name\*(C'\fR, if it exists.
.PP
The name is matched case insensitively.
.PP
Returns a node handle.
If the node was not found, this returns 0 without setting errno.
On error this returns 0 and sets errno.
.SS "hivex_node_parent"
.IX Subsection "hivex_node_parent"
.Vb 1
\& hive_node_h hivex_node_parent (hive_h *h, hive_node_h node);
.Ve
.PP
Return the parent of \f(CW\*(C`node\*(C'\fR.
.PP
The parent pointer of the root node in registry files that we
have examined seems to be invalid, and so this function will
return an error if called on the root node.
.PP
Returns a node handle.
On error this returns 0 and sets errno.
.SS "hivex_node_values"
.IX Subsection "hivex_node_values"
.Vb 1
\& hive_value_h *hivex_node_values (hive_h *h, hive_node_h node);
.Ve
.PP
Return the array of (key, value) pairs attached to this node.
.PP
Returns a 0\-terminated array of values.
The array must be freed by the caller when it is no longer needed.
On error this returns \s-1NULL\s0 and sets errno.
.SS "hivex_node_get_value"
.IX Subsection "hivex_node_get_value"
.Vb 1
\& hive_value_h hivex_node_get_value (hive_h *h, hive_node_h node, const char *key);
.Ve
.PP
Return the value attached to this node which has the name \f(CW\*(C`key\*(C'\fR,
if it exists.
.PP
The key name is matched case insensitively.
.PP
Note that to get the default key, you should pass the empty
string \f(CW""\fR here.  The default key is often written \f(CW"@"\fR, but
inside hives that has no meaning and won't give you the
default key.
.PP
Returns a value handle.
On error this returns 0 and sets errno.
.SS "hivex_value_key_len"
.IX Subsection "hivex_value_key_len"
.Vb 1
\& size_t hivex_value_key_len (hive_h *h, hive_value_h val);
.Ve
.PP
Return the length of the key (name) of a (key, value) pair as produced
by \f(CW\*(C`hivex_value_key\*(C'\fR. The length can legitimately be 0, so errno is 
the necessary mechanism to check for errors.
.PP
In the context of Windows Registries, a zero-length name means
that this value is the default key for this node in the tree.
This is usually written as \f(CW"@"\fR.
.PP
The key is recoded to \s-1UTF\-8\s0 and may contain embedded \s-1NUL\s0 characters.
.PP
Returns a size.
On error this returns 0 and sets errno.
.SS "hivex_value_key"
.IX Subsection "hivex_value_key"
.Vb 1
\& char *hivex_value_key (hive_h *h, hive_value_h val);
.Ve
.PP
Return the key (name) of a (key, value) pair.  The name
is reencoded as \s-1UTF\-8\s0 and returned as a string.
.PP
The string should be freed by the caller when it is no longer needed.
.PP
Note that this function can return a zero-length string.  In the
context of Windows Registries, this means that this value is the
default key for this node in the tree.  This is usually written
as \f(CW"@"\fR.
.PP
Returns a string.
The string must be freed by the caller when it is no longer needed.
On error this returns \s-1NULL\s0 and sets errno.
.SS "hivex_value_type"
.IX Subsection "hivex_value_type"
.Vb 1
\& int hivex_value_type (hive_h *h, hive_value_h val, hive_type *t, size_t *len);
.Ve
.PP
Return the data length and data type of the value in this (key, value)
pair.  See also \f(CW\*(C`hivex_value_value\*(C'\fR which returns all this
information, and the value itself.  Also, \f(CW\*(C`hivex_value_*\*(C'\fR functions
below which can be used to return the value in a more useful form when
you know the type in advance.
.PP
Returns 0 on success.
On error this returns \-1 and sets errno.
.SS "hivex_node_struct_length"
.IX Subsection "hivex_node_struct_length"
.Vb 1
\& size_t hivex_node_struct_length (hive_h *h, hive_node_h node);
.Ve
.PP
Return the length of the node data structure.
.PP
Returns a size.
On error this returns 0 and sets errno.
.SS "hivex_value_struct_length"
.IX Subsection "hivex_value_struct_length"
.Vb 1
\& size_t hivex_value_struct_length (hive_h *h, hive_value_h val);
.Ve
.PP
Return the length of the value data structure.
.PP
Returns a size.
On error this returns 0 and sets errno.
.SS "hivex_value_data_cell_offset"
.IX Subsection "hivex_value_data_cell_offset"
.Vb 1
\& hive_value_h hivex_value_data_cell_offset (hive_h *h, hive_value_h val, size_t *len);
.Ve
.PP
Return the offset and length of the value's data cell.
.PP
The data cell is a registry structure that contains the length
(a 4 byte, little endian integer) followed by the data.
.PP
If the length of the value is less than or equal to 4 bytes
then the offset and length returned by this function is zero
as the data is inlined in the value.
.PP
Returns 0 and sets errno on error.
.PP
Returns a value handle.
On error this returns 0 and sets errno.
.SS "hivex_value_value"
.IX Subsection "hivex_value_value"
.Vb 1
\& char *hivex_value_value (hive_h *h, hive_value_h val, hive_type *t, size_t *len);
.Ve
.PP
Return the value of this (key, value) pair.  The value should
be interpreted according to its type (see \f(CW\*(C`hive_type\*(C'\fR).
.PP
The value is returned as an array of bytes (of length \f(CW\*(C`len\*(C'\fR).
The value must be freed by the caller when it is no longer needed.
On error this returns \s-1NULL\s0 and sets errno.
.SS "hivex_value_string"
.IX Subsection "hivex_value_string"
.Vb 1
\& char *hivex_value_string (hive_h *h, hive_value_h val);
.Ve
.PP
If this value is a string, return the string reencoded as \s-1UTF\-8
\&\s0(as a C string).  This only works for values which have type
\&\f(CW\*(C`hive_t_string\*(C'\fR, \f(CW\*(C`hive_t_expand_string\*(C'\fR or \f(CW\*(C`hive_t_link\*(C'\fR.
.PP
Returns a string.
The string must be freed by the caller when it is no longer needed.
On error this returns \s-1NULL\s0 and sets errno.
.SS "hivex_value_multiple_strings"
.IX Subsection "hivex_value_multiple_strings"
.Vb 1
\& char **hivex_value_multiple_strings (hive_h *h, hive_value_h val);
.Ve
.PP
If this value is a multiple-string, return the strings reencoded
as \s-1UTF\-8 \s0(in C, as a NULL-terminated array of C strings, in other
language bindings, as a list of strings).  This only
works for values which have type \f(CW\*(C`hive_t_multiple_strings\*(C'\fR.
.PP
Returns a NULL-terminated array of C strings.
The strings and the array must all be freed by the caller when
they are no longer needed.
On error this returns \s-1NULL\s0 and sets errno.
.SS "hivex_value_dword"
.IX Subsection "hivex_value_dword"
.Vb 1
\& int32_t hivex_value_dword (hive_h *h, hive_value_h val);
.Ve
.PP
If this value is a \s-1DWORD \s0(Windows int32), return it.  This only works
for values which have type \f(CW\*(C`hive_t_dword\*(C'\fR or \f(CW\*(C`hive_t_dword_be\*(C'\fR.
.SS "hivex_value_qword"
.IX Subsection "hivex_value_qword"
.Vb 1
\& int64_t hivex_value_qword (hive_h *h, hive_value_h val);
.Ve
.PP
If this value is a \s-1QWORD \s0(Windows int64), return it.  This only
works for values which have type \f(CW\*(C`hive_t_qword\*(C'\fR.
.SS "hivex_commit"
.IX Subsection "hivex_commit"
.Vb 1
\& int hivex_commit (hive_h *h, const char *filename, int flags);
.Ve
.PP
Commit (write) any changes which have been made.
.PP
\&\f(CW\*(C`filename\*(C'\fR is the new file to write.  If \f(CW\*(C`filename\*(C'\fR is null/undefined
then we overwrite the original file (ie. the file name that was passed to
\&\f(CW\*(C`hivex_open\*(C'\fR).
.PP
Note this does not close the hive handle.  You can perform further
operations on the hive after committing, including making more
modifications.  If you no longer wish to use the hive, then you
should close the handle after committing.
.PP
The flags parameter is unused.  Always pass 0.
.PP
Returns 0 on success.
On error this returns \-1 and sets errno.
.SS "hivex_node_add_child"
.IX Subsection "hivex_node_add_child"
.Vb 1
\& hive_node_h hivex_node_add_child (hive_h *h, hive_node_h parent, const char *name);
.Ve
.PP
Add a new child node named \f(CW\*(C`name\*(C'\fR to the existing node \f(CW\*(C`parent\*(C'\fR.
The new child initially has no subnodes and contains no keys or
values.  The sk-record (security descriptor) is inherited from
the parent.
.PP
The parent must not have an existing child called \f(CW\*(C`name\*(C'\fR, so if you
want to overwrite an existing child, call \f(CW\*(C`hivex_node_delete_child\*(C'\fR
first.
.PP
Returns a node handle.
On error this returns 0 and sets errno.
.SS "hivex_node_delete_child"
.IX Subsection "hivex_node_delete_child"
.Vb 1
\& int hivex_node_delete_child (hive_h *h, hive_node_h node);
.Ve
.PP
Delete the node \f(CW\*(C`node\*(C'\fR.  All values at the node and all subnodes are
deleted (recursively).  The \f(CW\*(C`node\*(C'\fR handle and the handles of all
subnodes become invalid.  You cannot delete the root node.
.PP
Returns 0 on success.
On error this returns \-1 and sets errno.
.SS "hivex_node_set_values"
.IX Subsection "hivex_node_set_values"
.Vb 1
\& int hivex_node_set_values (hive_h *h, hive_node_h node, size_t nr_values, const hive_set_value *values, int flags);
.Ve
.PP
This call can be used to set all the (key, value) pairs
stored in \f(CW\*(C`node\*(C'\fR.
.PP
\&\f(CW\*(C`node\*(C'\fR is the node to modify.
.PP
The flags parameter is unused.  Always pass 0.
.PP
\&\f(CW\*(C`values\*(C'\fR is an array of (key, value) pairs.  There
should be \f(CW\*(C`nr_values\*(C'\fR elements in this array.
.PP
Any existing values stored at the node are discarded, and their
\&\f(CW\*(C`hive_value_h\*(C'\fR handles become invalid.  Thus you can remove all
values stored at \f(CW\*(C`node\*(C'\fR by passing \f(CW\*(C`nr_values = 0\*(C'\fR.
.PP
Returns 0 on success.
On error this returns \-1 and sets errno.
.SS "hivex_node_set_value"
.IX Subsection "hivex_node_set_value"
.Vb 1
\& int hivex_node_set_value (hive_h *h, hive_node_h node, const hive_set_value *val, int flags);
.Ve
.PP
This call can be used to replace a single \f(CW\*(C`(key, value)\*(C'\fR pair
stored in \f(CW\*(C`node\*(C'\fR.  If the key does not already exist, then a
new key is added.  Key matching is case insensitive.
.PP
\&\f(CW\*(C`node\*(C'\fR is the node to modify.
.PP
The flags parameter is unused.  Always pass 0.
.PP
\&\f(CW\*(C`value\*(C'\fR is a single (key, value) pair.
.PP
Existing \f(CW\*(C`hive_value_h\*(C'\fR handles become invalid.
.PP
Returns 0 on success.
On error this returns \-1 and sets errno.
.SH "WRITING TO HIVE FILES"
.IX Header "WRITING TO HIVE FILES"
The hivex library supports making limited modifications to hive files.
We have tried to implement this very conservatively in order to reduce
the chance of corrupting your registry.  However you should be careful
and take back-ups, since Microsoft has never documented the hive
format, and so it is possible there are nuances in the
reverse-engineered format that we do not understand.
.PP
To be able to modify a hive, you must pass the \f(CW\*(C`HIVEX_OPEN_WRITE\*(C'\fR
flag to \f(CW\*(C`hivex_open\*(C'\fR, otherwise any write operation will return with
errno \f(CW\*(C`EROFS\*(C'\fR.
.PP
The write operations shown below do not modify the on-disk file
immediately.  You must call \f(CW\*(C`hivex_commit\*(C'\fR in order to write the
changes to disk.  If you call \f(CW\*(C`hivex_close\*(C'\fR without committing then
any writes are discarded.
.PP
Hive files internally consist of a \*(L"memory dump\*(R" of binary blocks
(like the C heap), and some of these blocks can be unused.  The hivex
library never reuses these unused blocks.  Instead, to ensure
robustness in the face of the partially understood on-disk format,
hivex only allocates new blocks after the end of the file, and makes
minimal modifications to existing structures in the file to point to
these new blocks.  This makes hivex slightly less disk-efficient than
it could be, but disk is cheap, and registry modifications tend to be
very small.
.PP
When deleting nodes, it is possible that this library may leave
unreachable live blocks in the hive.  This is because certain parts of
the hive disk format such as security (sk) records and big data (db)
records and classname fields are not well understood (and not
documented at all) and we play it safe by not attempting to modify
them.  Apart from wasting a little bit of disk space, it is not
thought that unreachable blocks are a problem.
.SS "\s-1WRITE OPERATIONS WHICH ARE NOT SUPPORTED\s0"
.IX Subsection "WRITE OPERATIONS WHICH ARE NOT SUPPORTED"
.IP "\(bu" 4
Changing the root node.
.IP "\(bu" 4
Creating a new hive file from scratch.  This is impossible at present
because not all fields in the header are understood.  In the hivex
source tree is a file called \f(CW\*(C`images/minimal\*(C'\fR which could be used as
the basis for a new hive (but \fIcaveat emptor\fR).
.IP "\(bu" 4
Modifying or deleting single values at a node.
.IP "\(bu" 4
Modifying security key (sk) records or classnames.
Previously we did not understand these records.  However now they
are well-understood and we could add support if it was required
(but nothing much really uses them).
.SH "VISITING ALL NODES"
.IX Header "VISITING ALL NODES"
The visitor pattern is useful if you want to visit all nodes
in the tree or all nodes below a certain point in the tree.
.PP
First you set up your own \f(CW\*(C`struct hivex_visitor\*(C'\fR with your
callback functions.
.PP
Each of these callback functions should return 0 on success or \-1
on error.  If any callback returns \-1, then the entire visit
terminates immediately.  If you don't need a callback function at
all, set the function pointer to \s-1NULL.\s0
.PP
.Vb 10
\& struct hivex_visitor {
\&   int (*node_start) (hive_h *, void *opaque, hive_node_h, const char *name);
\&   int (*node_end) (hive_h *, void *opaque, hive_node_h, const char *name);
\&   int (*value_string) (hive_h *, void *opaque, hive_node_h, hive_value_h,
\&         hive_type t, size_t len, const char *key, const char *str);
\&   int (*value_multiple_strings) (hive_h *, void *opaque, hive_node_h,
\&         hive_value_h, hive_type t, size_t len, const char *key, char **argv);
\&   int (*value_string_invalid_utf16) (hive_h *, void *opaque, hive_node_h,
\&         hive_value_h, hive_type t, size_t len, const char *key,
\&         const char *str);
\&   int (*value_dword) (hive_h *, void *opaque, hive_node_h, hive_value_h,
\&         hive_type t, size_t len, const char *key, int32_t);
\&   int (*value_qword) (hive_h *, void *opaque, hive_node_h, hive_value_h,
\&         hive_type t, size_t len, const char *key, int64_t);
\&   int (*value_binary) (hive_h *, void *opaque, hive_node_h, hive_value_h,
\&         hive_type t, size_t len, const char *key, const char *value);
\&   int (*value_none) (hive_h *, void *opaque, hive_node_h, hive_value_h,
\&         hive_type t, size_t len, const char *key, const char *value);
\&   int (*value_other) (hive_h *, void *opaque, hive_node_h, hive_value_h,
\&         hive_type t, size_t len, const char *key, const char *value);
\&   /* If value_any callback is not NULL, then the other value_*
\&    * callbacks are not used, and value_any is called on all values.
\&    */
\&   int (*value_any) (hive_h *, void *opaque, hive_node_h, hive_value_h,
\&         hive_type t, size_t len, const char *key, const char *value);
\& };
.Ve
.IP "hivex_visit" 4
.IX Item "hivex_visit"
.Vb 1
\& int hivex_visit (hive_h *h, const struct hivex_visitor *visitor, size_t len, void *opaque, int flags);
.Ve
.Sp
Visit all the nodes recursively in the hive \f(CW\*(C`h\*(C'\fR.
.Sp
\&\f(CW\*(C`visitor\*(C'\fR should be a \f(CW\*(C`hivex_visitor\*(C'\fR structure with callback
fields filled in as required (unwanted callbacks can be set to
\&\s-1NULL\s0).  \f(CW\*(C`len\*(C'\fR must be the length of the 'visitor' struct (you
should pass \f(CW\*(C`sizeof (struct hivex_visitor)\*(C'\fR for this).
.Sp
This returns 0 if the whole recursive visit was completed
successfully.  On error this returns \-1.  If one of the callback
functions returned an error than we don't touch errno.  If the
error was generated internally then we set errno.
.Sp
You can skip bad registry entries by setting \f(CW\*(C`flag\*(C'\fR to
\&\f(CW\*(C`HIVEX_VISIT_SKIP_BAD\*(C'\fR.  If this flag is not set, then a bad registry
causes the function to return an error immediately.
.Sp
This function is robust if the registry contains cycles or
pointers which are invalid or outside the registry.  It detects
these cases and returns an error.
.IP "hivex_visit_node" 4
.IX Item "hivex_visit_node"
.Vb 1
\& int hivex_visit_node (hive_h *h, hive_node_h node, const struct hivex_visitor *visitor, size_t len, void *opaque);
.Ve
.Sp
Same as \f(CW\*(C`hivex_visit\*(C'\fR but instead of starting out at the root, this
starts at \f(CW\*(C`node\*(C'\fR.
.SH "THE STRUCTURE OF THE WINDOWS REGISTRY"
.IX Header "THE STRUCTURE OF THE WINDOWS REGISTRY"
Note: To understand the relationship between hives and the common
Windows Registry keys (like \f(CW\*(C`HKEY_LOCAL_MACHINE\*(C'\fR) please see the
Wikipedia page on the Windows Registry.
.PP
The Windows Registry is split across various binary files, each
file being known as a \*(L"hive\*(R".  This library only handles a single
hive file at a time.
.PP
Hives are n\-ary trees with a single root.  Each node in the tree
has a name.
.PP
Each node in the tree (including non-leaf nodes) may have an
arbitrary list of (key, value) pairs attached to it.  It may
be the case that one of these pairs has an empty key.  This
is referred to as the default key for the node.
.PP
The (key, value) pairs are the place where the useful data is
stored in the registry.  The key is always a string (possibly the
empty string for the default key).  The value is a typed object
(eg. string, int32, binary, etc.).
.SS "\s-1RELATIONSHIP TO .REG FILES\s0"
.IX Subsection "RELATIONSHIP TO .REG FILES"
The hivex C library does not care about or deal with Windows .REG
files.  Instead we push this complexity up to the Perl
\&\fIWin::Hivex\fR\|(3) library and the Perl programs
\&\fIhivexregedit\fR\|(1) and \fIvirt\-win\-reg\fR\|(1).
Nevertheless it is useful to look at the relationship between the
Registry and .REG files because they are so common.
.PP
A .REG file is a textual representation of the registry, or part of the
registry.  The actual registry hives that Windows uses are binary
files.  There are a number of Windows and Linux tools that let you
generate .REG files, or merge .REG files back into the registry hives.
Notable amongst them is Microsoft's \s-1REGEDIT\s0 program (formerly known as
\&\s-1REGEDT32\s0).
.PP
A typical .REG file will contain many sections looking like this:
.PP
.Vb 10
\& [HKEY_LOCAL_MACHINE\eSOFTWARE\eClasses\eStack]
\& "@"="Generic Stack"
\& "TileInfo"="prop:System.FileCount"
\& "TilePath"=str(2):"%systemroot%\e\esystem32"
\& "ThumbnailCutoff"=dword:00000000
\& "FriendlyTypeName"=hex(2):40,00,25,00,53,00,79,00,73,00,74,00,65,00,6d,00,52,00,6f,00,\e
\&  6f,00,74,00,25,00,5c,00,53,00,79,00,73,00,74,00,65,00,6d,00,\e
\&  33,00,32,00,5c,00,73,00,65,00,61,00,72,00,63,00,68,00,66,00,\e
\&  6f,00,6c,00,64,00,65,00,72,00,2e,00,64,00,6c,00,6c,00,2c,00,\e
\&  2d,00,39,00,30,00,32,00,38,00,00,00,d8
.Ve
.PP
Taking this one piece at a time:
.PP
.Vb 1
\& [HKEY_LOCAL_MACHINE\eSOFTWARE\eClasses\eStack]
.Ve
.PP
This is the path to this node in the registry tree.  The first part,
\&\f(CW\*(C`HKEY_LOCAL_MACHINE\eSOFTWARE\*(C'\fR means that this comes from a hive
file called \f(CW\*(C`C:\eWINDOWS\eSYSTEM32\eCONFIG\eSOFTWARE\*(C'\fR.
\&\f(CW\*(C`\eClasses\eStack\*(C'\fR is the real path part,
starting at the root node of the \f(CW\*(C`SOFTWARE\*(C'\fR hive.
.PP
Below the node name is a list of zero or more key-value pairs.  Any
interior or leaf node in the registry may have key-value pairs
attached.
.PP
.Vb 1
\& "@"="Generic Stack"
.Ve
.PP
This is the \*(L"default key\*(R".  In reality (ie. inside the binary hive)
the key string is the empty string.  In .REG files this is written as
\&\f(CW\*(C`@\*(C'\fR but this has no meaning either in the hives themselves or in this
library.  The value is a string (type 1 \- see \f(CW\*(C`enum hive_type\*(C'\fR
above).
.PP
.Vb 1
\& "TileInfo"="prop:System.FileCount"
.Ve
.PP
This is a regular (key, value) pair, with the value being a type 1
string.  Note that inside the binary file the string is likely to be
\&\s-1UTF\-16LE\s0 encoded.  This library converts to and from \s-1UTF\-8\s0 strings
transparently in some cases.
.PP
.Vb 1
\& "TilePath"=str(2):"%systemroot%\e\esystem32"
.Ve
.PP
The value in this case has type 2 (expanded string) meaning that some
%...% variables get expanded by Windows.  (This library doesn't know
or care about variable expansion).
.PP
.Vb 1
\& "ThumbnailCutoff"=dword:00000000
.Ve
.PP
The value in this case is a dword (type 4).
.PP
.Vb 1
\& "FriendlyTypeName"=hex(2):40,00,....
.Ve
.PP
This value is an expanded string (type 2) represented in the .REG file
as a series of hex bytes.  In this case the string appears to be a
\&\s-1UTF\-16LE\s0 string.
.SH "NOTE ON THE USE OF ERRNO"
.IX Header "NOTE ON THE USE OF ERRNO"
Many functions in this library set errno to indicate errors.  These
are the values of errno you may encounter (this list is not
exhaustive):
.IP "\s-1ENOTSUP\s0" 4
.IX Item "ENOTSUP"
Corrupt or unsupported Registry file format.
.IP "\s-1HIVEX_NO_KEY\s0" 4
.IX Item "HIVEX_NO_KEY"
Missing root key.
.IP "\s-1EINVAL\s0" 4
.IX Item "EINVAL"
Passed an invalid argument to the function.
.IP "\s-1EFAULT\s0" 4
.IX Item "EFAULT"
Followed a Registry pointer which goes outside
the registry or outside a registry block.
.IP "\s-1ELOOP\s0" 4
.IX Item "ELOOP"
Registry contains cycles.
.IP "\s-1ERANGE\s0" 4
.IX Item "ERANGE"
Field in the registry out of range.
.IP "\s-1EEXIST\s0" 4
.IX Item "EEXIST"
Registry key already exists.
.IP "\s-1EROFS\s0" 4
.IX Item "EROFS"
Tried to write to a registry which is not opened for writing.
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
.IP "\s-1HIVEX_DEBUG\s0" 4
.IX Item "HIVEX_DEBUG"
Setting HIVEX_DEBUG=1 will enable very verbose messages.  This is
useful for debugging problems with the library itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIhivexget\fR\|(1),
\&\fIhivexml\fR\|(1),
\&\fIhivexsh\fR\|(1),
\&\fIhivexregedit\fR\|(1),
\&\fIvirt\-win\-reg\fR\|(1),
\&\fIWin::Hivex\fR\|(3),
\&\fIguestfs\fR\|(3),
<http://libguestfs.org/>,
\&\fIvirt\-cat\fR\|(1),
\&\fIvirt\-edit\fR\|(1),
<http://en.wikipedia.org/wiki/Windows_Registry>.
.SH "AUTHORS"
.IX Header "AUTHORS"
Richard W.M. Jones (\f(CW\*(C`rjones at redhat dot com\*(C'\fR)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2009\-2010 Red Hat Inc.
.PP
Derived from code by Petter Nordahl-Hagen under a compatible license:
Copyright (C) 1997\-2007 Petter Nordahl-Hagen.
.PP
Derived from code by Markus Stephany under a compatible license:
Copyright (C) 2000\-2004 Markus Stephany.
.PP
This library is free software; you can redistribute it and/or
modify it under the terms of the \s-1GNU\s0 Lesser General Public
License as published by the Free Software Foundation;
version 2.1 of the License only.
.PP
This library is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See the \s-1GNU\s0
Lesser General Public License for more details.
